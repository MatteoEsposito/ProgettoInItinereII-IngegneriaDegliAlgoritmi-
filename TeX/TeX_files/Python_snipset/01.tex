\begin{minipage}{0.49\linewidth}
\begin{Verbatim}[frame=topline,numbers=left,label=Codice,framesep=3mm]
R = dict((v,0) for v in V)
for s in V:
	S = []
	P = dict((w, []) for w in V)
	sg = dict((t, 0) for t in V)
	sg[s] = 1
	d = dict((t, -1) for t in V)
	d[s] = 0
	Q = deque([])                                   
	Q.append(s)
	\end{Verbatim}
\end{minipage}\hfill
\begin{minipage}{0.49\linewidth}
	\begin{Verbatim}
	L'algoritmo di brandes chiede subito di
	allocare  spazio  per  un  dizionario R 
	inizializzando tutte le sue chiavi a 0 
	ed  indicizzandole  con gli ID dei nodi 
	del grafo. 
	L'iterazione principale viene effetuata
	ponendo come nodo  "s" ( sorgente )
	uno dopo l'altro tutti i nodi del  grafo, 
	è lecito quindi asserire che ciò aggiunga 
	subito una Complessità Temporale pari 
	ad un O(n).
	L'algoritmo prosegue poi ad iniziallizare: 
	una Pila S, contenente nodi in ordine
	non crescente di distanza(s,v);
	un dizionario P di predecessori composto da 
	quei nodi che giacciono sui cammini minimi;
	un dizionario sigma ( qui "sg") contenente
	il numero di cammini minimi passanti per 
	il nodo v; un dizionario "d"
	contente i valori di "dependency" del nodo v
	\end{Verbatim}

\end{minipage}
\newline \newline